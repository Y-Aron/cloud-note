# 泛微开发从入门到放弃

## 1. 前端开发基础

### 1.1 ` ECMAScript6`的使用

> ECMAScript 和 JavaScript 的关系是：前者是后者的规格，后者是前者的一种实现。
>
> ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指 “下一代 JavaScript 语言”。

## 1.2 ES6常见的语法

### 1.2.1 let 和 const 命令

ES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。

```javascript
{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
```

`const`声明一个只读的常量。一旦声明，常量的值就不能改变。

```javascript
const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
```

### 1.2.2 变量的解构赋值

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）

如果解构不成功，变量的值就等于`undefined`

- 数组的解构赋值

```javascript
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```

- 对象的解构赋值

```javascript
// 常见用法
let { bar, foo, baz } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"
baz // undefined


// foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined

// 嵌套使用
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};
// 第一个p作为变量，则进行赋值，第二个p作为模式，不会进行赋值
let { p, p: [x, { y }] } = obj;
x // "Hello"
y // "World"
p // ["Hello", {y: "World"}]
```

### 1.2.3 ... 运算符

- 函数 `rest` 参数的使用

```javascript
function f(a, ...b) {
    console.log(a, b)
}
f(1,2,3,4,5) // 1 [2,3,4,5]
```

- 数组拆解

```javascript
const a = [1,2,3]
const b = [4,5,6]
const c = [...a, ...b]
c // [1,2,3,4,5,6]
```

- 对象拆解

```javascript
const obj = { a: 111, b:222 }
const copyObj = { ...obj, c: 333 }
copyObj // { a: 111, b:222, c: 333 }
```

### 1.2.4 函数的扩展

- 参数默认值：ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。

```javascript
// 基本用法
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello

// 参数默认值可以与解构赋值的默认值，结合起来使用。
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
```

- 箭头函数：ES6 允许使用（`=>`）定义函数。

```javascript
// 基本用法
var f = v => v;
// 等同于
var f = function (v) {
  return v;
};

// 箭头函数可以与变量解构结合使用。
const full = ({ first, last }) => first + ' ' + last;
// 等同于
function full(person) {
  return person.first + ' ' + person.last;
}

// rest 参数与箭头函数结合
const numbers = (...nums) => nums;
numbers(1, 2, 3, 4, 5) // [1,2,3,4,5]
const headAndTail = (head, ...tail) => [head, tail];
headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]]
```

## 1.3 React基础

> React 是一个用于构建用户界面的 `Javascript` 库。
>
> React 主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。
>
> React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。
>
> React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。

### 1.3.1 JSX语法

`JSX` 即`Javascript XML`，它是对`JavaScript` 语法扩展。React 使用 `JSX` 来替代常规的 `JavaScript`。你也可以认为`JSX`其实就是`JavaScript`。当遇到 `<`，`JSX`就当HTML解析，遇到 `{` 就当`JavaScript`解析。

- 基本用法

```javascript
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);
// 等价于
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
```

- 在 `JSX` 中嵌入表达式

 声明了一个名为 `name` 的变量，然后在 `JSX` 中使用它，并将它包裹在大括号中： 

```javascript
const name = 'Josh Perez';
const element = <h1>Hello, {name}</h1>;
```

### 1.3.2 React简单实例

```jsx
class HelloMessage extends React.Component {
  render() {
    return (
      <div>
        Hello {this.props.name}
      </div>
    );
  }
}

ReactDOM.render(
  <HelloMessage name="React" />,
  document.getElementById('hello-example')
);
```

## 2. 基于E-code的开发平台

> 推荐 OA 上的所有前端开发统一使用 ecode 进行代码开发管理。
>
> Ecode 官方文档： https://e-cloudstore.com/ecode/doc 
>
> E9 技术站地址： https://e-cloudstore.com/e9/index2.html?tdsourcetag=s_pctim_aiomsg

本章节是针对 `ecode` 文档的细节补充

### 2.1 流程开发

关于流程页面上的前端开发，建议不要直接使用代码块进行开发！所有的开发代码统一在 ecode 平台上进行，然后在流程表单代码块中插入如下代码，或者使用 [全局流程代码块整合](https://e-cloudstore.com/ecode/doc#4、全局流程代码块整合) 方案加载代码。

![image-20200107145848071](asset/image-20200107145848071.png)

```javascript
// 建议在代码块中添加 代码在ecode 中的文件路径，方便寻找对应的代码。
// 默认分类/测试
ecodeSDK.load({
    // ${appId}泛值ecode平台中的文件夹主键id
    id: '${appId}',
    noCss: true,
    cb: function() {}
})
```

### 2.2 建模开发

#### 2.2.1 布局代码块

建模布局页面的使用方式与流程基本一致，在代码块中加载代码块。不建议使用[全局流程代码块整合](https://e-cloudstore.com/ecode/doc#4、全局流程代码块整合)进行加载。

![image-20200107160111293](asset/image-20200107160111293.png)

#### 2.2.2 自定义按钮

> 后端应用中心 -> 建模引擎 -> 查询
>
> 任选一个查询页面 -> 自定义按钮 -> 右键 -> 新建![1570360554483](asset/1570360554483-1578384220902.png) 

1. 方法体中存在多行代码时，每个语句必须以`;`结尾；否则会报错！

2. `params`的值等于 `‘field1+field2+field3’` 这个值是一个字符串

3. `id`指的是数据`ID`

> 自定义按钮实现效果
>
> ![1570109435919](asset/1570109435919-1578384267504.png)

---

> 使用 ecode 进行代码管理
>
> 新建前置文件 `index.js`并将方法挂到全局对象 `window.g` 下（window.g 为自定义对象，可以任意）
>
> ![1570109735133](asset/1570109735133-1578384444396.png)

自定义按钮的配置如下： ![1570109991787](asset/1570109991787-1578384481424.png)  

#### 2.2.3 页面扩展

> 后端应用中心 -> 建模引擎 -> 模块
>
> 任选一个模块 -> 页面扩展 -> 右键 -> 新建
>
> ![1570110626080](asset/1570110626080-1578384589261.png) 

- 扩展用途：卡片页面、查询列表（批量操作）、卡片页面和查询列表
  - 卡片页面：可以设置页面扩展显示在卡片信息页面，可以选择在新建页面、编辑页面、查看页面显示页面扩展。
  - 查询列表（批量操作）：设置在查询列表时，则会在引用该模块的查询列表的批量操作中显示页面扩展项，在批量操作中勾选后会在前台列表中显示对应的页面扩展项。
  - 卡片页面和查询列表：可以设置页面扩展项既显示在对应的卡片页面又显示在查询列表（批量操作）中。
- `javascript:test()`: 该方法可以在 `建模引擎 -> 查询 -> 该模块的查询列表 -> 编辑代码块` 中定义

![1570110945435](asset/1570110945435-1578384628940.png) 

 ![1570110988895](asset/1570110988895-1578384642998.png) 

> 前端按钮测试如下
>
> ![1570110886190](asset/1570110886190-1578384686739.png) 

- 页面扩展同样可以配置 `ecode`使用，将**链接目标地址**改成: `javascript: window.g.test()`即可，建议这样做，方便后续代码维护。

## 3. 后端开发

> E9 后端开发详见：https://e-cloudstore.com/e9/file/E9BackendDdevelopmentGuide.pdf 
>
> 本章节是针对笔记中未描述的开发点进行补充！

### 3.1 JavaWeb项目搭建

- 使用 `Idea` 创建一个`Java`项目
- 添加 `jar` 依赖：**File -> Project Structure -> Project Settings -> Libraries**

需要添加的`ecology`的依赖路径有: `ecology/WEB-INF/lib`; `resin/lib`; `ecology/classbean`;

其中`classbean`是必须要引入的, 其他两个按需引入

- 编译`Java`文件将编译后的`class`文件放入`ecology/classbean/`目录下即可

### 3.2 Maven项目搭建

- 将 `ecology/classbean` 打成 `jar` 包，进入 ecology 目录，执行以下命令

命令：`jar -cvf ecology-[版本号].jar classbean`

例如：`jar -cvf ecology-9.1909.04.jar classbean`

- 将 `ecology-9.1909.04.jar` 加入到本地 maven 仓库

```shell
// -Dfile参数指的是jar的路径
mvn install:install-file -DgroupId=com.weaver -DartifactId=ecology -Dversion=9.1909.04 -Dpackaging=jar -Dfile=ecology-9.1909.04.jar
```

- 创建 `maven` 项目，并在 `POM.xml` 中配置如下

```xml
<dependency>
	<groupId>com.weaver</groupId>
	<artifactId>ecology</artifactId>
	<version>9.1909.04</version>
</dependency>
```

### 3.3 自定义 Java 接口

#### 3.3.1 流程节点前后附加操作

> 在节点前后附加操作中可设置接口动作，完成流程自定义附加操作
>
> 接口动作标识不能重复；接口动作类文件必须是类全名，该类必须实现接 `weaver.interfaces.workflow.action` 方法 `public String execute(RequestInfo request)`

代码参考：

```java
import com.weaver.general.Util;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import weaver.hrm.User;
import weaver.interfaces.workflow.action.Action;
import weaver.soa.workflow.request.*;

public class TestAction implements Action {

    private String customParam; //自定义参数
    private final Logger logger = LoggerFactory.getLogger(TestAction.class);

    @Override
    public String execute(RequestInfo requestInfo) {
        logger.debug("进入action requestid = {}", requestInfo.getRequestid());
        showCurrentForm(requestInfo);

        showFormProperty(requestInfo);

        showDetailsTables(requestInfo);

        logger.debug("Action 执行完成，传入自定义参数：{}", this.getCustomParam());
//        requestInfo.getRequestManager().setMessagecontent("返回自定义的错误消息");
//        requestInfo.getRequestManager().setMessageid("自定义消息ID");
//        return FAILURE_AND_CONTINUE;  // 注释的三句话一起使用才有效果！
        return SUCCESS;
    }

    private void showCurrentForm(RequestInfo requestInfo) {
        String requestid = requestInfo.getRequestid(); // 请求ID
        String requestLevel = requestInfo.getRequestlevel(); // 请求紧急程度
        // 当前操作类型 submit:提交/reject:退回
        String src = requestInfo.getRequestManager().getSrc();
        // 流程ID
        String workFlowId = requestInfo.getWorkflowid();
        // 表单名称
        String tableName = requestInfo.getRequestManager().getBillTableName();
        // 表单数据ID
        int bill_id = requestInfo.getRequestManager().getBillid();
        // 获取当前操作用户对象
        User user = requestInfo.getRequestManager().getUser();
        // 请求标题
        String requestName =  requestInfo.getRequestManager().getRequestname();
        // 当前用户提交时的签字意见
        String remark = requestInfo.getRequestManager().getRemark();
        // 表单ID
        int form_id = requestInfo.getRequestManager().getFormid();
        // 是否是自定义表单
        int isbill = requestInfo.getRequestManager().getIsbill();

        logger.debug("requestid: {}", requestid);
        logger.debug("requestLevel: {}", requestLevel);
        logger.debug("src: {}", src);
        logger.debug("workFlowId: {}", workFlowId);
        logger.debug("tableName: {}", tableName);
        logger.debug("bill_id: {}", bill_id);
        logger.debug("user: {}", user);
        logger.debug("requestName: {}", requestName);
        logger.debug("remark: {}", remark);
        logger.debug("form_id: {}", form_id);
        logger.debug("isbill: {}", isbill);
    }
    /**
     * 获取主表数据
     */
    private void showFormProperty(RequestInfo requestInfo) {
        logger.debug("获取主表数据 ...");
        // 获取表单主字段值
        Property[] properties = requestInfo.getMainTableInfo().getProperty();
        for (Property property : properties) {
            // 主字段名称
            String name = property.getName();
            // 主字段对应的值
            String value = Util.null2String(property.getValue());
            logger.debug("name: {}, value: {}", name, value);
        }
    }

    /**
     * 取明细数据
     */
    private void showDetailsTables(RequestInfo requestInfo) {
        logger.debug("获取所有明细表数据 ...");
        // 获取所有明细表
        DetailTable[] detailTables = requestInfo.getDetailTableInfo().getDetailTable();
        if (detailTables.length > 0) {
            for (DetailTable table: detailTables) {
                // 当前明细表的所有数据，按行存储
                Row[] rows = table.getRow();
                for (Row row: rows) {
                    // 每行数据再按列存储
                    Cell[] cells = row.getCell();
                    for (Cell cell: cells) {
                        // 明细字段名称
                        String name = cell.getName();
                        // 明细字段的值
                        String value = cell.getValue();
                        logger.debug("name: {}, value: {}", name, value);
                    }
                }
            }
        }
    }

    public String getCustomParam() {
        return customParam;
    }

    public void setCustomParam(String customParam) {
        this.customParam = customParam;
    }
}
```

接口配置：

> 后端应用中心 -> 流程引擎 -> 路径管理 -> 路径设置
>
> 任选一个流程 -> 流程设置 -> 节点信息
>
> 任选一个节点 -> 节点前 / 节点后附加操作
>
> ![1570114991641](asset/1570114991641-1578388215464.png) 
>
> ![1570158010000](asset/1570158010000-1578388231163.png) 

#### 3.3.2 建模页面扩展接口

> 页面扩展 -> 接口动作 -> 自定义接口动作
>
> 执行页面扩展的后续操作，通过配置自定义 `Java`接口动作类实现。
>
> 接口动作类文件必须是类全名。该类必须继承 `weaver.formmode.customjavacode.AbstractModeExpandJavaCode` 方法 `public void doModeExpand(Map param)`

参考代码如下：

```java
import weaver.conn.RecordSet;
import weaver.general.Util;
import weaver.hrm.User;
import weaver.soa.workflow.request.RequestInfo;
import weaver.formmode.customjavacode.AbstractModeExpandJavaCode;

import java.util.Map;

public class ModeExpandTemplate extends AbstractModeExpandJavaCode {

    @Override
    public void doModeExpand(Map<String, Object> param) throws Exception {
        // 当前用户
        User user = (User) param.get("user");
        int billid = -1; // 数据id
        int modeid = -1; // 模块id
        RequestInfo requestInfo = (RequestInfo) param.get("RequestInfo");
        if (requestInfo != null) {
            billid = Util.getIntValue(requestInfo.getRequestid());
            modeid = Util.getIntValue(requestInfo.getWorkflowid());
            if (billid > 0 && modeid > 0) {
                RecordSet rs = new RecordSet();
                //------请在下面编写业务逻辑代码------
            }
        }
    }
}
```

接口配置：

> 后端应用中心 -> 建模引擎 -> 模块
>
> 任选一个模块 -> 页面扩展 -> 任选一个扩展名称 -> 接口动作 -> 点击 `+` 号 -> 自定义接口动作
>
> ![1570158149458](asset/1570158149458-1578388336608.png) 

#### 3.3.3 计划任务接口

> 通过配置自定义 `Java`接口的实现类，定时执行相应的代码

- 按照设定的时间定时执行任务，计划任务标识不能重复
- 计划任务类必须是类的全名，该类必须继承 `weaver.interfaces.schedule.BaseCronJob`类,重写方法`public void execute() {}`
- 时间格式按`Cron`表达式的定义

参考代码如下：

```java
import weaver.interfaces.schedule.BaseCronJob;

public class CronTemplate extends BaseCronJob {

    @Override
    public void execute() {
        //------请在下面编写业务逻辑代码------
    }
}
```

> 配置：后端应用中心 -> 集成中心 -> 计划任务 -> 任务列表 -> 新建
>
> ![1570158310329](asset/1570158310329-1578388463419.png)

> **通过计划任务列表的每个计划任务的自定义按钮，可以对每个任务进行状态操作，具体使用如下所示**
>
> ![1570156694722](asset/1570156694722-1578388463421.png)

状态详解：

1. 启用: 计划任务将根据Cron表达式执行;
2. 禁用: 计划任务将不再执行，重启服务也不会再次执行;
3. 暂停: 针对计划任务进行停止，重启服务将恢复正常状态;
4. 恢复: 针对暂停状态的计划任务进行恢复，恢复后计划任务将继续执行;
5. 执行: 单次执行计划任务，不影响Cron表达式周期执行;
6. 测试: 检查填写的计划任务类是否符合规范（继承weaver.interfaces.schedule.BaseCronJob类,重写方法public void execute() {}）

#### 3.3.4 自定义按钮接口

> 通过配置自定义`Java`类，判断自定义按钮在查询列表中是否显示

参考代码如下：

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import weaver.formmode.interfaces.PopedomCommonAction;

public class CustomBtnShowTemplate implements PopedomCommonAction {

    private Logger logger = LoggerFactory.getLogger(CustomBtnShowTemplate.class);

    /**
     * 得到是否显示操作项
     * @param modeid 模块id
     * @param customid 查询列表id
     * @param uid 当前用户id
     * @param billid 表单数据id
     * @param buttonname 按钮名称
     * @retrun "true"或者"false"true显示/false不显示
     */
    @Override
    public String getIsDisplayOperation(String modeid, String customid,String uid, String billid, String buttonname) {
        logger.debug("modeId: {}", modeid);
        logger.debug("customId: {}", customid);
        logger.debug("uid: {}", uid);
        logger.debug("billId: {}", billid);
        logger.debug("buttonname: {}", buttonname);
        return "false";
    }
}
```

> 配置：后端应用中心 -> 建模引擎 -> 查询
>
> 任选一个查询列表 -> 自定义按钮 -> 右键 -> 新建
>
> ![1570158498273](asset/1570158498273-1578388537556.png)

前端查询列表中，由于接口中返回false，则 **受控按钮** 不显示

![1570158575523](asset/1570158575523-1578388586511.png) 

### 3.4  Rest Api 接口

> E-cology9 相比 E8，增加了 rest api接口定义框架 `jersey`，使用该框架可以很方便的使用http请求进行相关开发。

####  3.4.1 开放接口

- 流程表单数据接口：https://www.evernote.com/l/AuMO8ps7HVpMlYkjCMpRC9xyc1VYIcbo1I0/
- 流程代办列表接口：https://www.evernote.com/l/AuM0l0TdGS9OvZuHd1eztup5KNwIgFokDTU/ 
- 流程列表数据接口：https://www.evernote.com/l/AuP8WpYtOmhHkYgnhs7aOKy_AL9kMACGWm4/ 

#### 3.4.2 自定义 Api 接口

创建 `com.api.demo.web.TestActionApi.java`

```java
package com.api.demo.web;

import com.demo.jack.web.TestAction;

import javax.ws.rs.Path;

@Path("/demo/test")
public class TestActionApi extends TestAction {
}
```

创建 `com.demo.jack.web.TestAction`

```java
package com.demo.jack.web;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

public class TestAction {

    @GET
    @Path("/hello")
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello weaver!";
    }
}
```

启动 `resin`，打开浏览器输入：`http://127.0.0.1/api/demo/test/hello` 

输出：`hello weaver!`

### 3.5 项目结构和代码规范

> 每个人都有属于自己的一套开发规范，以下是一套相对而言比较规范的二开规范，仅供参考

#### 3.5.1 使用 Weaverboot-E9（beta）

> Weaverboot-E9 提供一套完整的 IOC + AOP 的解决方案。可以很快速的代理所有的接口。同时提供类似与spring 的依赖注入的写法。方便快速编码。该方案目前属于内测版，但推荐使用！

- `ecology/WEB-INF/web.xml` 加入以下配置

```xml
<servlet>
    <servlet-name>WeaIocInitServlet</servlet-name>
    <servlet-class>com.weaverboot.frame.ioc.prop.init.WeaIocInitServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
        <servlet-name>WeaIocInitServlet</servlet-name>
        <url-pattern>/weaIoc/init</url-pattern>
</servlet-mapping>
<filter>
    <filter-name>WeaComponentFilter</filter-name>
    <filter-class>com.weaverboot.frame.ioc.filter.WeaComponentFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>WeaComponentFilter</filter-name>
    <url-pattern>/api/*</url-pattern>
</filter-mapping>
```

- `ecology/WEB-INF/prop/` 中创建 `weaverboot.properties`

```properties
# 扫包路径
scanPackage=com.demo.jack.**
```

- `ecology/WEB-INF/lib/`  下添加 `Weaverboot-E9.jar`(暂不提供下载链接，想体验找云商店)

#### 3.5.2 基于 weaverboot 的代码分层

> 暂时不对数据层进行拆分， 未对`mybatis` 进行整合。直接使用 RecordSet 对数据库进行操作即可！

- 接口层

```java
package com.demo.jack.web;

import com.demo.jack.service.TestService;
import com.weaverboot.frame.ioc.anno.fieldAnno.WeaAutowired;
import lombok.extern.slf4j.Slf4j;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Slf4j(topic = "debug")
public class TestAction {

    @WeaAutowired
    private TestService testService;

    @GET
    @Path("/get")
    @Produces(MediaType.TEXT_PLAIN)
    public String testGet() {
        log.debug("{}", testService.getMessage());
        return testService.getMessage();
    }
}
```

- 服务层

```java
package com.demo.jack.service;

public interface TestService {

    String getMessage();
}
```

```java
package com.demo.jack.service.impl;

import com.demo.jack.service.TestService;
import com.weaverboot.frame.ioc.anno.classAnno.WeaIocService;

@WeaIocService
public class TestServiceImpl implements TestService {

    @Override
    public String getMessage() {
        return "this is test service impl ret list";
    }
}
```

#### 3.5.3 使用 Wcode

> Wcode 是针对二次开发项目中一些常用方法的提取的工具类，包括流程表单的快速定义，流程创建以及 Mybatis 的相关使用。
>
> 文档详见：

## 4. SQL 缓存相关

> Ecology 平台具有数据缓存机制，在项目中尽量不要直接对数据库进行操作，如执行存储过程或者触发器。如果实在没有办法则需要进行 Sql 缓存配置（切记！）

- 原则上禁止通过非程序渠道直接修改oa数据库数据。如果一定要修改，请修改完数据后，chrome浏览器访问/commcache/cacheMonitor.jsp界面，点击重启加载配置。这样操作修改的数据可以及时生效。
- 如果存在第三方程序修改oa数据库的表，则需要将会修改的表的名称以（名称=名称）的格式增加到例外配置文件：ecology\WEB-INF\prop\cacheBackList.properties中，然后再使用重启加载配置，使其生效。
- 如果客户二次开发中存在非RecordSet（系统标准sql操作类）类修改数据库里的表，也需要将该表名按注意事项2的方式操作，将其加入例外配置文件中。
- 如果客户二次开发中还存在调用自己新建的存储过程，视图，函数（方法）。也需要将存储过程，视图，函数（方法）中涉及到的表名加入到例外配置文件中ecology\WEB-INF\prop\cacheBackList.properties。然后再使用重启加载配置，使其生效。
- 集群环境，如果开启sql缓存，必须所有节点全部开启，关闭也必须所有节点同时全部关闭，否则必然存在缓存不同步问题

## 5. 异构系统对接

### 5.1 接口白名单配置

> 对于 ecology 平台而言，所有的 rest api 接口都要经过登陆认证。否则不允许接入。在内网环境或者保证网络安全的情况下可以使用接口白名单配置。跳过登陆认证进行接口访问。

- `weaver_session_filter.properties`(系统)

外部配置文件，配置放行的路径地址。(启用了`weaver_session_filter.properties`会自动覆盖原`web.xml`中的路径）

- `weaver_session_filter_dev.properties`(用户自定义)

用户自定义配置文件，配置放行的路径地址(项目二开的路径建议放用户定义配置文件，升级时不被覆盖)会自动覆盖web.xml 中的路径地址。

```properties
# 头部验证路径 适用于 EM
checkurl=/api/hrm/emmanager;
# 头部验证放行路径 适用于 EM
uncheckurl=/api/ec/dev/app/getCheckSystemInfo;/api/ec/dev/app/emjoin;
#  session验证放行 不检查放行的路径（白名单）
unchecksessionurl=/api/doc/upload/mobile/uploadFile;/api/doc/upload/mobile/shareFile;/weaver/weaver.file.FileDownload;/api/ec/dev/app/getCheckSystemInfo;/api/ec/dev/app/emjoin;/api/hrm/emmanager/;
```

### 5.2 Token 认证

> 相比接口白名单，使用 token 进行接口访问相对而言更加安全，其数据不易被抓取。
>
> token 认证文档：[Token认证](http://wcode.store/#/./weaver/Token异构系统认证)